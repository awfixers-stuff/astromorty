---
# Docker Compose configuration for DEVELOPMENT
#
# This file is optimized for local development with:
# - Hot reload for source code changes (requires docker compose watch)
# - Local builds from source
# - Source code volume mounts for plugins and assets
# - Adminer enabled by default (dev profile)
# - Development-friendly defaults (restart: no, debug mode)
#
# Usage:
#   docker compose up -d  # Start all services
#   docker compose up --watch  # Start with hot reload
#   docker compose --profile dev up -d  # Explicitly enable dev profile
#
# For production deployments, use: docker compose -f compose.production.yaml up -d
#
services:
  # PostgreSQL service (optional - use Supabase or external PostgreSQL instead)
  # Uncomment and configure if you want to use local PostgreSQL instead of Supabase
  # astromorty-postgres:
  #   container_name: astromorty-postgres
  #   hostname: astromorty-postgres
  #   image: postgres:17-alpine@sha256:ff4ccc02b97e0ebb6b328ef9ff92522f95586f83be6801896b615088defc8ad2
  #   restart: 'no'
  #   environment:
  #     POSTGRES_DB: ${POSTGRES_DB:-astromortydb}
  #     POSTGRES_USER: ${POSTGRES_USER:-astromortyuser}
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-ChangeThisToAStrongPassword123!}
  #     POSTGRES_INITDB_ARGS: --encoding=UTF-8 --lc-collate=C --lc-ctype=C
  #   ports: ['127.0.0.1:${POSTGRES_PORT:-5432}:5432']
  #   volumes:
  #     - tux_postgres_data:/var/lib/postgresql/data
  #     - ./docker/postgres/postgresql.conf:/etc/postgresql/postgresql.conf:ro
  #   command: postgres -c config_file=/etc/postgresql/postgresql.conf
  #
  #   # Logging configuration
  #   logging:
  #     driver: json-file
  #     options:
  #       max-size: 10m
  #       max-file: '3'
  #       compress: 'true'
  #   healthcheck:
  #     test:
      #       - CMD-SHELL
      #       - pg_isready -U ${POSTGRES_USER:-astromortyuser} -d ${POSTGRES_DB:-astromortydb} -h localhost
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5
  #     start_period: 30s
  #   stop_grace_period: 30s
  astromorty:
    container_name: astromorty
    hostname: astromorty
    # Development: Build from source by default, or use pre-built image
    image: ${ASTROMORTY_IMAGE:-ghcr.io/allthingslinux/astromorty}:${ASTROMORTY_IMAGE_TAG:-latest}
    build:
      context: .
      dockerfile: Containerfile
      target: production
      args:
        VERSION: ${VERSION:-dev}
        GIT_SHA: ${GIT_SHA:-}
        BUILD_DATE: ${BUILD_DATE:-}
        DEVCONTAINER: ${DEVCONTAINER:-0}
    volumes:
      # Mount source code for development (hot reload via watch mode)
      - ./config:/app/config:ro  # Configuration files
      - ./src/tux/plugins:/app/tux/plugins:ro  # Custom plugins
      - ./assets:/app/assets:ro  # Static assets
      - ./docker/entrypoint.sh:/entrypoint.sh:ro  # Entrypoint script
      - ./data/cache:/app/.cache  # Application cache
      - ./data/temp:/app/temp  # Temporary files
      - ./data/user-home:/home/nonroot  # User home directory
      # Note: Source code changes are synced via docker compose watch (see develop section)
    env_file: [.env]
    environment:
      ASTROMORTY_VERSION: ${VERSION:-dev}
      # Development settings
      DEBUG: ${DEBUG:-false}
      # Startup configuration
      MAX_STARTUP_ATTEMPTS: ${MAX_STARTUP_ATTEMPTS:-3}
      STARTUP_DELAY: ${STARTUP_DELAY:-5}
      # Database connection
      # For Supabase: Set DATABASE_URL instead of individual POSTGRES_* vars
      # DATABASE_URL: postgresql+psycopg://user:password@host:port/database?sslmode=require
      # For local PostgreSQL: Uncomment and configure below
      # POSTGRES_HOST: astromorty-postgres
      # POSTGRES_PORT: 5432
      # POSTGRES_DB: ${POSTGRES_DB:-astromortydb}
      # POSTGRES_USER: ${POSTGRES_USER:-astromortyuser}
      # POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-ChangeThisToAStrongPassword123!}
    restart: no  # Development: manual restart control
    # depends_on:
    #   tux-postgres:
    #     condition: service_healthy
    # Uncomment above if using local PostgreSQL service
    healthcheck:
      # Verify the bot process is running
      test:
        - CMD-SHELL
        - ps aux | grep -v grep | grep -q "tux start" || exit 1
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 40s
    stop_grace_period: 30s
    # Development: Security settings disabled for easier debugging
    # Production compose file enables: security_opt, read_only, tmpfs
    logging:
      driver: json-file
      options:
        max-size: 10m
        max-file: '3'

    # Hot reload configuration (enabled with: docker compose --watch up)
    # Syncs source code changes without rebuilding the container
    develop:
      watch:
        # Python source code (hot reload)
        - action: sync
          path: ./src
          target: /app/src
          ignore:
            - __pycache__/
            - '*.pyc'
            - '*.pyo'
            - '*.pyd'
            - .pytest_cache/
            - .mypy_cache/
            - .coverage
        # Sync configuration changes
        - action: sync
          path: ./config
          target: /app/config
        # Sync custom modules
        - action: sync
          path: ./src/tux/plugins
          target: /app/tux/plugins
        # Sync assets
        - action: sync
          path: ./assets
          target: /app/assets
        # Rebuild when dependencies change
        - action: rebuild
          path: pyproject.toml
        - action: rebuild
          path: uv.lock
        # Restart when environment or Docker config changes
        - action: sync+restart
          path: .env
          target: /app/.env
        - action: sync+restart
          path: compose.yaml
          target: /app/compose.yaml
  # tux-adminer:
  #   # Database management UI - enabled by default in development
  #   # Note: Adminer only works with local PostgreSQL. For Supabase, use Supabase Studio.
  #   image: adminer:latest@sha256:ae1d4d7774c544d084e42887a318e6b0f47ad8c60fe1661d9278ef169c8b4eaa
  #   container_name: tux-adminer
  #   hostname: tux-adminer
  #   profiles: [dev]  # Enable with: docker compose --profile dev up -d
  #   restart: 'no'
  #   depends_on:
  #     astromorty-postgres:
  #       condition: service_healthy
  #   ports: ['${ADMINER_PORT:-8080}:8080']
    environment:
      # Plugin configuration for autologin
      ADMINER_DEFAULT_SYSTEM: pgsql
      ADMINER_DEFAULT_SERVER: astromorty-postgres
      ADMINER_DEFAULT_NAME: ${POSTGRES_USER:-astromortyuser}
      ADMINER_DEFAULT_PASS: ${POSTGRES_PASSWORD:-ChangeThisToAStrongPassword123!}
      ADMINER_DEFAULT_DATABASE: ${POSTGRES_DB:-astromortydb}
      ADMINER_AUTOLOGIN_AUTOSUBMIT: ${ADMINER_AUTO_LOGIN:-true}
      # Additional plugins
      ADMINER_PLUGINS: backward-keys tables-filter dump-date dump-json dump-xml dump-zip
        edit-calendar edit-foreign enum-option foreign-system json-column pretty-json-column
        table-indexes-structure table-structure row-numbers config
      ADMINER_THEME: dracula
    volumes:
      # Mount autologin plugin to plugins-enabled directory
      # Adminer automatically loads plugins from this directory
      - ./docker/adminer/autologin-form.php:/var/www/html/plugins-enabled/autologin-form.php:ro
# volumes:
#   tux_postgres_data:
#     driver: local
# Uncomment above if using local PostgreSQL service
